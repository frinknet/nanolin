#!/bin/sh

# basic config
SRC="$(readlink -f "$1")"
IMG="$(basename "$1")"
DIR="$(readlink -f "$(dirname "$PWD/$1")")"
WRK="$DIR/work/$IMG"
GEN="$DIR/work/out"
TAR="$DIR/work/$IMG-release.tgz"
OUT="$DIR/$IMG-release.tgz"
REL="Nanolin.$IMG"

# load config file if it exists
[ -e "$DIR/config" ] && source "$DIR/config"

# alias chroot for easy work
alias busybox="$WRK/usr/bin/busybox"
alias workrun="'$NLDIR/chroot' '$WRK'"
alias workbox="workrun /usr/bin/busybox"

# display info pretty
info() {
	echo -e "\e[1m$@\e[21m"
}

# remove a file from the build
rem_file() {
	for x in $@; do
		[ -e "/build$x" ] && echo "Removing $x"
		rm -fr "/build$x"
	done
}

# add a file to the build
add_file() {
	for x in $@; do
		echo "Adding $x"
		workbox cp "$x" "/build$x"
	done
}

# add a directory to the build
add_dir() {
	for x in $@; do
		echo "Adding $x"
		workbox cp -fr "$x/*" "/build/$x/"
	done
}

# download a URL
get_url() {
	for x in $@; do
		[ -e "${x##*/}" ] && continue

		echo "Retrieving $x"
		wget "$x"
	done
}

# setup a root directory
setup_root() {
	rm -rf $1
	mkdir -p $1
	cd $1

	mkdir -p boot
	mkdir -p dev
	mkdir -p etc/nanolin.d
	mkdir -p home
	mkdir -p mnt/user
	mkdir -p mnt/uuid
	mkdir -p mnt/label
	mkdir -p mnt/dev
	mkdir -p mnt/nobs
	mkdir -p proc
	mkdir -p root
	mkdir -p run/lock
	mkdir -p run/distro
	mkdir -p sys
	mkdir -p tmp/var
	mkdir -p usr/bin
	mkdir -p usr/lib
	mkdir -p usr/local
	mkdir -p usr/include
	mkdir -p usr/share
	mkdir -p usr/src
	mkdir -p var/log
	mkdir -p var/cache
	mkdir -p var/spool/cron
	mkdir -p var/spool/cron/crontabs
	mkdir -p var/spool/mail
	ln -s usr/bin bin
	ln -s usr/bin sbin
	ln -s usr/lib lib
	ln -s usr/lib lib64
	ln -s ../bin usr/sbin
	ln -s ../lib usr/lib64
	ln -s ../proc/mounts etc/mtab
	ln -s ../../etc/hostname run/distro/hostname
	ln -s ../../etc/username run/distro/username
	ln -s ../../etc/version run/distro/version
	ln -s ../../etc/remote run/distro/remote
	ln -s ../run var/run
	ln -s ../run/lock var/lock
	ln -s ../distro run/lock/distro
	ln -s ../tmp/var var/tmp
	ln -s spool/mail var/mail
	chmod -R 777 tmp
	chmod -R 722 run/distro
	chmod -R 777 run/lock
	cd -
}

# apply a patch to source
patch_src() {
	local _SRC="$1"
	local _CNT="0"

	shift

	for x in $@; do
		[ -e "${x%.patch}.applied" ] && continue
	
		echo "Applying $x"
	
		(cd $_SRC; busybox patch -Np1 -i ../$x) > ${x%.patch}.applied
		$((++CNT))
	done

	[ "$_CNT" -gt 0 ] && return 0 || return 1 
}

# create image from directory
img_dir() {
	echo "Creating image $2 from $1"

	(cd "$1"; find . | busybox cpio -o -H newc) | busybox gzip -9 > "$2"
}

# run a shell script in the given directory
run_in_dir() {
	local _SRC=$1
	local _DIR=$2

	info "Running $_SRC"

	if ! (cd "$_DIR"; source "$_SRC"); then
		echo "Error in $_SRC"
		echo "Running in $_DIR"

		return 1
	fi
}

# make sure we have a base director
[ ! -d "$SRC" ] && echo "
Missing directories to build.
" && exit

# make sure we have signify installed
if [ ! -e "/usr/bin/signify" ]; then
	info "Signify needs to be installed to sign packages."

	yes | sudo pacman -Sy signify

	echo "Run again to continue."
	exit
fi

# generate verify keys if needed
if [ ! -e "$DIR/verify.pub" ] || [ ! -e "$DIR/verify.sec" ]; then
	info "Generating verification keys for release"

	signify -Gn -p "$DIR/verify.pub" -s "$DIR/verify.sec"
fi

# discover dependencies
get_deps () {
	local _DEP="$@"

	for s in $@; do
		local _SRC="$(readlink -f "$s")"

		for d in $(cat $_SRC/depends 2>/dev/null); do
			[ -z "$(echo " $_DEP " | busybox grep -o " $d ")" ] && _DEP="$(get_deps $d $_DEP)"
		done
	done

	echo $_DEP
}

# setup dependency chain once
if [ -z "$DEP" ]; then
       	DEP="$(get_deps $@)"

	[ "$(echo $@)" != "$DEP" ] && exec "$0" $DEP
fi

# now we can start building
info "Preparing to build from $SRC" 

# recreate build directory fresh 
mkdir -p "$GEN"
echo "setup $WRK/build"
setup_root "$WRK/build" 
rm -rf "$WRK/image.gz" "$TAR"

# make sure we have a version but only record once
if [ ! -e "$GEN/.version" ]; then
	date +%y.%m-G%d%H%M%S > "$GEN/.version"
fi

# create release string
echo "Storing version and verify.pub key"
REL="$REL-$(cat "$GEN/.version")"
OUT="$REL.tgz"

# add version and verify.pub to etc
mkdir -p "$WRK/etc"
echo "$REL" > "$WRK/etc/version"
cp "$DIR/verify.pub" "$WRK/etc/verify.pub"

# packstrap busybox + packages
info "Pacstrap $SRC/packages"
! pacstrap -d "$WRK" busybox $(grep -v '#' "$SRC/packages" 2>/dev/null) && echo "
Error in pacstrap call. Aborting build for $IMG.

	pacstrap -d "$WRK" busybox $(grep -v '#' "$SRC/packages" 2>/dev/null)

It may be a good idea to call:

	pacman-key --refresh-keys

That should take care of any latent problems.
" && exit

# now we move to the actual build process
info "Preparing build environment"

# install busybox in overlay build directory
echo "Setting up busybox commands in chroot"
workbox --install -s /bin

# tar copy everything except build.sh, pakages and depends from $SRC
echo "Copying files to $WRK/build"
tar -C "$SRC" --exclude=build.sh --exclude=packages --exclude=depends -cf - . | tar -C "$WRK/build" -xf -

# if we have a build.sh run it now
[ -e "$SRC/build.sh" ] && run_in_dir "$SRC/build.sh" "$WRK" || echo "Error in $SRC/build.sh" && exit

# now start to put the build image together 
info "Adding image to release"

# if there is not a build image file genrate one if there is a build directory
[ ! -e "$WRK/image.gz" ] && [ -e "$WRK/build" ] && img_dir "$WRK/build" "$WRK/image.gz"

# error if the image didn't get created
[ ! -e "$WRK/image.gz" ] && echo "No image found at $WRK/image.gz" && exit

# add the image to the generation folder
echo "Copying image to $GEN/$IMG"
mv "$WRK/image.gz" "$GEN/$IMG"

# check if we need to  continue building next target
[ -z "$@" ] || exec "$0" $@

# finalize target
info "Finalizing $REL release tarball"

# set kernel name to $IMG
[ -z "$KNL" ] && export KNL="$IMG"

# then remove an argument
shift

# then set $DSK
[ -z "$DSK" ] && export DSK="$@"

# generate boot file
echo "PATH /$REL/
DEFAULT boot
LABEL boot
KERNEL $KNL
INCLUDE /.bootflags" > "$GEN/boot"

[ -n "$DSK" ] && echo "INITRD ${DSK/ /,}" >> "$GEN/boot"

# generate manifest
echo "Updating manifest $GEN/.manifest"
(cd "$GEN"; "$WRK/bin/busybox" sha1sum *) > "$GEN/.manifest"

# generate signature
echo "Signing manifest $GEN/.signature"
signify -S -s "$DIR/verify.sec" -m "$GEN/.manifest" -x "$GEN/.signature"

# create release
tar -C "$GEN" -czf "$TAR" .

# sign the release
echo "Signing release $OUT"
signify -Sz -s "$DIR/verify.sec" -m "$TAR" -x "$OUT"

# clean generation output file
rm -rf "$GEN"
